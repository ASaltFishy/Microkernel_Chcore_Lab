## 主要代码块实现思路
我的文件系统的实现参考了FAT文件系统，SD卡分区抽象如下：

```
|<- FAT block bitmap(1 block) ->|<- FAT(500 blocks) ->|<- Data(3200 blocks) ->|
```
- FAT block bitmap: 记录blocks的分配使用情况，一个Data Block对应该bitmap中的一个bit
- FAT: 以链表的方式记录每个文件涉及的block块，FAT一个node为一个byte，存储它的下一个block的id
- Data: 存储文件数据，该区域的block拥有从零开始的block index。根目录也以文件的方式存储，起始于0号block，其内容（目录项）如下所示，记录了文件名、文件大小、起始block index
  ```c
  struct dir_entry {
    char file_name[24];
    int block_num;
    int size
    };
  ```

代码具体实现思路：

`alloc_block`, `free_block`通过读取和修改bitmap实现分配和释放data block

`naive_fs_access`: 读取data block 0中根目录的内容，遍历各个文件名寻找该文件是否在根目录中

`naive_fs_creat`: 调用alloc_block分配block，在根目录中添加该文件对应的目录项

`naive_fs_pread`: 在根目录中读取该文件元数据，至对应block中读取文件内容，若读取的部分跨越了多个block，则根据第一个block的index号至FAT中寻找下一个block，如此反复直至需要内容均被读取，最后修改根目录中的元数据

`naive_fs_pwrite`: 在根目录中读取该文件元数据，结合FAT至对应block中修改文件内容，该过程中扩大了文件大小，可能需要alloc_block和修改FAT表，最后再修改根目录中的文件元数据

`naive_fs_unlink`: 将文件元数据从根目录中删除，调用free_block将文件的Data Block释放


## 思考题
### 思考题 1：请自行查阅资料，并阅读userland/servers/sd中的代码，回答以下问题:
- circle中还提供了SDHost的代码。SD卡，eMMC和SDHost三者之间的关系是怎么样的？
  
  SD卡是常用的存储介质。eMMC作为常见SD控制器的一种，用于控制SD存储卡和SDIO设备的访问和通信。
  SDHost是一种标准的接口协议，eMMC控制器支持SDHost接口标准。

- 请详细描述Chcore是如何与SD卡进行交互的？即Chcore发出的指令是如何输送到SD卡上，又是如何得到SD卡的响应的。(提示: IO设备常使用MMIO的方式映射到内存空间当中)
  
  SD卡寄存器通过MMIO直接映射到物理地址空间中，CPU上的操作系统可以直接通过直接读写寄存器的方式将指令发送至SD卡寄存器处，SD卡发现寄存器值被更新，读取指令后再使用DMA的方式从内存中读取大量数据写入SD卡，或是将SD卡数据读至内存中，这一步不需要CPU的参与，IO设备直接与内存交互，完成DMA数据交互之后IO设备向CPU发送中断，CPU接受中断并进行相应处理。

- 请简要介绍一下SD卡驱动的初始化流程。
  
  检查SD卡是否上电 --> 设置SD控制器、SD卡版本等 --> 开始读写SD卡寄存器对SD卡进行配置-->设置好sd卡相关的参数变量

- 在驱动代码的初始化当中，设置时钟频率的意义是什么？为什么需要调用TimeoutWait进行等待?
  
  设置时钟频率是为了与CPU的始终同步，保证信息传输和采样的速率同步，防止出现乱序或者信息丢失的情况。
  TimeoutWait 的调用是为了等待寄存器设置的生效。在设置寄存器之后，芯片可能需要一些时间才能完成配置。这种等待是为了确保寄存器的设置在有效时间内完成，以避免在接下来的操作中出现不可预测的问题。


### 思考题2：查阅资料了解 SD 卡是如何进行分区，又是如何识别分区对应的文件系统的？尝试设计方案为 ChCore 提供多分区的 SD 卡驱动支持，设计其解析与挂载流程。本题的设计部分请在实验报告中详细描述，如果有代码实现，可以编写对应的测试程序放入仓库中提交。

- SD卡分区是通过分区表实现的，在SD卡的特定位置存储了SD卡的分区表，记录了SD卡上各个分区的起始位置、大小和文件系统类型等信息。
若要识别分区对应的文件系统，操作系统首先根据分区表中的信息，将分区加载为独立的逻辑驱动器。然后对于每个加载的分区，操作系统会尝试识别其文件系统类型。它会读取分区的文件系统的元数据，并使用相应的算法和规则来确定文件系统的类型（如FAT32、NTFS、ext4等）。

设计：
1. 分区表：在SD卡0号block处记录分区表，每个分区表项长4 bytes，格式为：
   
   ```|<- 分区ID(1 byte) ->|<- 分区起始block号(1 byte) ->|<- 分区结束block号(1 byte) ->|<- 分区文件系统类型标识符(1 byte) ->|```
   解析时读取SD卡 block[0] 后可获得相应分区信息
2. 挂载流程：寻找到该分区对应的SD卡位置，依据其分级系统类型对该分区进行格式化、初始化，并将该分区挂载至/media目录下的一个子目录，保存SD卡分区ID与目录的映射。
3. 需要对SD卡分区进行读写时，OS根据文件路径的前缀找到对应分区，并调用对应文件系统的处理函数即可。
   

## 可能的改进方向
目前我的shell程序中run_cmd函数在执行完命令(如spawn)返回之后，其线程将yield同时阻塞控制流，导致spawn等函数无法继续运行。

为了防止阻塞，我只能在run_cmd函数的末尾加入了一个死循环才能让后续流程继续进行，但这导致shell只能读取一行run_cmd命令，仅供通过测试，不是万全之策，之后我应该想办法修复这个bug。