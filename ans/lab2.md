#### 思考题 1：请思考多级页表相比单级页表带来的优势和劣势（如果有的话），并计算在 AArch64 页表中分别以 4KB 粒度和 2MB 粒度映射 0～4GB 地址范围所需的物理内存大小（或页表页数量）。
优势：多级页表使页表能在内存中离散存储；离散的存储也使得内核只为实际使用的地址申请页表页，而不像单机页表必须要开辟连续的大空间，从而节省了内存空间。
劣势：地址翻译时访问内存的次数增加，降低了查询速度。
4KB：2^11(三级页表)+2^2(二级页表)+1(一级页表)个页表页
2MB：2^2(二级页表)+1(一级页表)个页表页

#### 思考题 3：请思考在 init_boot_pt 函数中为什么还要为低地址配置页表，并尝试验证自己的解释。
因为随后打开MMU功能后即在低地址处使用虚拟地址，若不配置页表会引发段错误（实际上没有段错误，内核尚未启动不存在段错误一说）
验证：将映射低地址的代码段注释后重新尝试启动，在开启MMU的指令结束，执行下一条指令时报错cannot access memory
![Alt text](cannot%20access%20mem.png)

#### 思考题 4：请解释 ttbr0_el1 与 ttbr0_el1 是具体如何被配置的，给出代码位置，并思考页表基地址配置后为何需要ISB指令。
文件tools.S函数el1_mmu_activate的汇编代码中line246-line250：将页表的物理地址（在init_boot_pt中设置的boot_ttbr0_l0和boot_ttbr1_l0写入了ttbr0_el1和ttbr1_el1寄存器）
ISB指令实现内存屏障，保证各个指令顺序执行，防止后面的打开MMU操作因为流水线预取等原因在尚未设置ttbr寄存器时就被执行造成错误。


#### 思考题 8：阅读 Arm Architecture Reference Manual，思考要在操作系统中支持写时拷贝（Copy-on-Write，CoW）[^cow]需要配置页表描述符的哪个/哪些字段，并在发生缺页异常（实际上是 permission fault）时如何处理。
将支持写时拷贝页面的AP属性设置为11，将其SH属性设置为00，EL0只能读取该处数据，且数据不可共享，一个进程对此处私有数据的修改不能被其他进程观察到。
发生permission fault时，OS在物理内存上开辟一块新的空间，将用户试图写入的页复制到该处，并设置新的页为可写入，然后重新执行一遍异常前的操作。


#### 思考题 9：为了简单起见，在 ChCore 实验中没有为内核页表使用细粒度的映射，而是直接沿用了启动时的粗粒度页表，请思考这样做有什么问题。
导致启动后一段时间翻译地址时频繁出现缺页异常，多次下陷至内核态处理该异常造成启动时程序运行性能差。